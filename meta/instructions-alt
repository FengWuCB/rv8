# RV32I
lui        "Load Upper Immediate"                           "rd ← imm"
auipc      "Add Upper Immediate to PC"                      "rd ← pc + imm"
jal        "Jump and Link"                                  "rd ← pc + 4 ; pc ← pc + imm"
jalr       "Jump and Link Register"                         "rd ← pc + 4 ; pc ← rs1 + imm"
beq        "Branch Equal"                                   "if rs1 = rs2 then pc ← pc + imm"
bne        "Branch Not Equal"                               "if rs1 ≠ rs2 then pc ← pc + imm"
blt        "Branch Less Than "                              "if rs1 < rs2 then pc ← pc + imm"
bge        "Branch Greater than Equal"                      "if rs1 ≥ rs2 then pc ← pc + imm"
bltu       "Branch Less Than Unsigned"                      "if rs1 < rs2 then pc ← pc + imm"
bgeu       "Branch Greater than Equal Unsigned"             "if rs1 ≥ rs2 then pc ← pc + imm"
lb         "Load Byte"                                      "rd ← s8[rs1 + imm]"
lh         "Load Half"                                      "rd ← s16[rs1 + imm]"
lw         "Load Word"                                      "rd ← s32[rs1 + imm]"
lbu        "Load Byte Unsigned"                             "rd ← u8[rs1 + imm]"
lhu        "Load Half Unsigned"                             "rd ← u16[rs1 + imm]"
lwu        "Load Word Unsigned"                             "rd ← u32[rs1 + imm]"
sb         "Store Byte"                                     "u8[rs1 + imm] ← rs2"
sh         "Store Half"                                     "u16[rs1 + imm] ← rs2"
sw         "Store Word"                                     "u32[rs1 + imm] ← rs2"
addi       "Add Immediate"                                  "rd ← rs1 + sx(imm)"
slti       "Set Less Than Immediate"                        "rd ← sx(rs1) < sx(imm)"
sltiu      "Set Less Than Immediate Unsigned"               "rd ← ux(rs1) < ux(imm)"
xori       "Xor Immediate"                                  "rd ← ux(rs1) ⊕ sx(imm)"
ori        "Or Immediate"                                   "rd ← ux(rs1) ∨ sx(imm)"
andi       "And Immediate"                                  "rd ← ux(rs1) ∧ sx(imm)"
slli       "Shift Left Logical Immediate"                   "rd ← ux(rs1) « sx(imm)"
srli       "Shift Right Logical Immediate"                  "rd ← ux(rs1) » sx(imm)"
srai       "Shift Right Arithmetic Immediate"               "rd ← sx(rs1) » sx(imm)"
add        "Add"                                            "rd ← sx(rs1) + sx(rs2)"
sub        "Subtract"                                       "rd ← sx(rs1) - sx(rs2)"
sll        "Shift Left Logical"                             "rd ← ux(rs1) « rs2"
slt        "Set Less Than"                                  "rd ← sx(rs1) < sx(rs2)"
sltu       "Set Less Than Unsigned"                         "rd ← ux(rs1) < ux(rs2)"
xor        "Xor"                                            "rd ← ux(rs1) ⊻ ux(rs2)"
srl        "Shift Right Logical"                            "rd ← ux(rs1) » rs2"
sra        "Shift Right Arithmetic"                         "rd ← sx(rs1) » rs2"
or         "Or"                                             "rd ← sx(rs1) ∨ sx(rs2)"
and        "And"                                            "rd ← sx(rs1) ∧ sx(rs2)"
fence      "Fence"
fence.i    "Fence Instruction"

# RV64I
ld         "Load Double"                                    "rd ← u64[rs1 + imm]"
sd         "Store Double"                                   "u64[rs1 + imm] ← rs2"
addiw      "Add Immediate Word"                             "rd ← s32(rs1) + imm"
slliw      "Shift Left Logical Immediate Word"              "rd ← s32(u32(rs1) « imm)"
srliw      "Shift Right Logical Immediate Word"             "rd ← s32(u32(rs1) » imm)"
sraiw      "Shift Right Arithmetic Immediate Word"          "rd ← s32(rs1) » imm"
addw       "Add Word"                                       "rd ← s32(rs1) + s32(rs2)"
subw       "Subtract Word"                                  "rd ← s32(rs1) - s32(rs2)"
sllw       "Shift Left Logical Word"                        "rd ← s32(u32(rs1) « rs2)"
srlw       "Shift Right Logical Word"                       "rd ← s32(u32(rs1) » rs2)"
sraw       "Shift Right Arithmetic Word"                    "rd ← s32(rs1) » rs2"

# RV32M
mul        "Multiply"                                       "rd ← ux(rs1) × ux(rs2)"
mulh       "Multiply High Signed Signed"                    "rd ← (sx(rs1) × sx(rs2)) » xlen"
mulhsu     "Multiply High Signed Unsigned"                  "rd ← (sx(rs1) × ux(rs2)) » xlen"
mulhu      "Multiply High Unsigned Unsigned"                "rd ← (ux(rs1) × ux(rs2)) » xlen"
div        "Divide Signed"                                  "rd ← sx(rs1) ÷ sx(rs2)"
divu       "Divide Unsigned"                                "rd ← ux(rs1) ÷ ux(rs2)"
rem        "Remainder Signed"                               "rd ← sx(rs1) mod sx(rs2)"
remu       "Remainder Unsigned"                             "rd ← ux(rs1) mod ux(rs2)"

# RV64M 
mulw       "Multiple Word"                                  "rd ← u32(rs1) × u32(rs2)"
divw       "Divide Signed Word"                             "rd ← s32(rs1) ÷ s32(rs2)"
divuw      "Divide Unsigned Word"                           "rd ← u32(rs1) ÷ u32(rs2)"
remw       "Remainder Signed Word"                          "rd ← s32(rs1) mod s32(rs2)"
remuw      "Remainder Unsigned Word"                        "rd ← u32(rs1) mod u32(rs2)"

# RV32A    "RV32A Standard Extension for Atomic Instructions"

lr.w       "Load Reserved Word"                             "lr ← rs1 ∥ rd ← sx(s32[rs1])"
sc.w       "Store Conditional Word"                         "if lr = rs1 then u32[rs1] ← u32(rs2); rd ← 0 else rd ← 1"
amoswap.w  "Atomic Swap Word"                               "rd ← s32[rs1] ∥ u32[rs1] ← s32(rs2)"
amoadd.w   "Atomic Add Word"                                "rd ← s32[rs1] ∥ u32[rs1] ← s32(rs2) + s32[rs1]"
amoxor.w   "Atomic Xor Word"                                "rd ← s32[rs1] ∥ u32[rs1] ← s32(rs2) ⊻ s32[rs1]"
amoor.w    "Atomic Or Word"                                 "rd ← s32[rs1] ∥ u32[rs1] ← s32(rs2) ∨ s32[rs1]"
amoand.w   "Atomic And Word"                                "rd ← s32[rs1] ∥ u32[rs1] ← s32(rs2) ∧ s32[rs1]"
amomin.w   "Atomic Minimum Word"                            "rd ← s32[rs1] ∥ u32[rs1] ← s32_min(s32(rs2), s32[rs1])"
amomax.w   "Atomic Maximum Word"                            "rd ← s32[rs1] ∥ u32[rs1] ← s32_max(s32(rs2), s32[rs1])"
amominu.w  "Atomic Minimum Unsigned Word"                   "rd ← s32[rs1] ∥ u32[rs1] ← u32_min(u32(rs2), u32[rs1])"
amomaxu.w  "Atomic Maximum Unsigned Word"                   "rd ← s32[rs1] ∥ u32[rs1] ← u32_max(u32(rs2), u32[rs1])"

# RV64A    "RV64A Standard Extension for Atomic Instructions (in addition to RV32A)"

lr.d       "Load Reserved Double Word"                      "lr ← rs1 ∥ rd ← sx(s64[rs1])"
sc.d       "Store Conditional Double Word"                  "if lr = rs1 then u64[rs1] ← u64(rs2); rd ← 0 else rd ← 1"
amoswap.d  "Atomic Swap Double Word"                        "rd ← s64[rs1] ∥ u64[rs1] ← s64(rs2)"
amoadd.d   "Atomic Add Double Word"                         "rd ← s64[rs1] ∥ u64[rs1] ← s64(rs2) + s64[rs1]"
amoxor.d   "Atomic Xor Double Word"                         "rd ← s64[rs1] ∥ u64[rs1] ← s64(rs2) ⊻ s64[rs1]"
amoor.d    "Atomic Or Double Word"                          "rd ← s64[rs1] ∥ u64[rs1] ← s64(rs2) ∨ s64[rs1]"
amoand.d   "Atomic And Double Word"                         "rd ← s64[rs1] ∥ u64[rs1] ← s64(rs2) ∧ s64[rs1]"
amomin.d   "Atomic Minimum Double Word"                     "rd ← s64[rs1] ∥ u64[rs1] ← s64_min(s64(rs2), s64[rs1])"
amomax.d   "Atomic Maximum Double Word"                     "rd ← s64[rs1] ∥ u64[rs1] ← s64_max(s64(rs2), s64[rs1])"
amominu.d  "Atomic Minimum Unsigned Double Word"            "rd ← s64[rs1] ∥ u64[rs1] ← u64_min(u64(rs2), u64[rs1])"
amomaxu.d  "Atomic Maximum Unsigned Double Word"            "rd ← s64[rs1] ∥ u64[rs1] ← u64_max(u64(rs2), u64[rs1])"

# RV32S    "RV32S Standard Extension for Supervisor-level Instructions"

ecall      "Environment Call"
ebreak     "Environment Break to Debugger"
uret       "User Return"
sret       "System Return"
hret       "Hypervisor Return"
mret       "Machine-Mode Return"
dret       "Debug-Mode Return"
sfence.vm  "Supervisor Memory Management Fence"
wfi        "Wait For Interrupt"
csrrw      "CSR Atomic Read Write"
csrrs      "CSR Atomic Set Bit"
csrrc      "CSR Atomic Clear Bit"
csrrwi     "CSR Atomic Read Write Immediate"
csrrsi     "CSR Atomic Set Bit Immediate"
csrrci     "CSR Atomic Clear Bit Immediate"

# RV32F    "RV32F Standard Extension for Single-Precision Floating-Point"

flw        "FP Load (SP)"                                   "frd ← f32[rs1 + imm]"
fsw        "FP Store (SP)"                                  "f32[rs1 + imm] ← f32(frs2)"
fmadd.s    "FP Fused Multiply Add (SP)"                     "frm ← rm ; frd ← f32(frs1) × f32(frs2) + f32(frs3)"
fmsub.s    "FP Fused Multiply Subtract (SP)"                "frm ← rm ; frd ← f32(frs1) × f32(frs2) - f32(frs3)"
fnmadd.s   "FP Negate fused Multiply Add (SP)"              "frm ← rm ; frd ← -(f32(frs1) × f32(frs2) + f32(frs3))"
fnmsub.s   "FP Negate fused Multiply Subtract (SP)"         "frm ← rm ; frd ← -(f32(frs1) × f32(frs2) - f32(frs3))"
fadd.s     "FP Add (SP)"                                    "frm ← rm ; frd ← f32(frs1) + f32(frs2)"
fsub.s     "FP Subtract (SP)"                               "frm ← rm ; frd ← f32(frs1) - f32(frs2)"
fmul.s     "FP Multiply (SP)"                               "frm ← rm ; frd ← f32(frs1) × f32(frs2)"
fdiv.s     "FP Divide (SP)"                                 "frm ← rm ; frd ← f32(frs1) ÷ f32(frs2)"
fsgnj.s    "FP Sign-injection (SP)"                         "frd ← f32_copysign(f32(frs1), f32(frs2))"
fsgnjn.s   "FP Sign-injection Negate (SP)"                  "frd ← f32_copysign(f32(frs1), -f32(frs2))"
fsgnjx.s   "FP Sign-injection Xor (SP)"                     "frd ← f32_xorsign(f32(frs1), f32(frs2))"
fmin.s     "FP Minimum (SP)"                                "frd ← f32_min(f32(frs1), f32(frs2))"
fmax.s     "FP Maximum (SP)"                                "frd ← f32_max(f32(frs1), f32(frs2))"
fsqrt.s    "FP Square Root (SP)"                            "frm ← rm ; frd ← f32_sqrt(f32(frs1))"
fle.s      "FP Less Than Equal (SP)"                        "if f32(frs1) ≤ f32(frs2) then rd ← 1 else rd ← 0"
flt.s      "FP Less Than (SP)"                              "if f32(frs1) < f32(frs2) then rd ← 1 else rd ← 0"
feq.s      "FP Equal (SP)"                                  "if f32(frs1) = f32(frs2) then rd ← 1 else rd ← 0"
fcvt.w.s   "FP Convert Float to Word (SP)"                  "frm ← rm ; rd ← s32(f32(frs1))"
fcvt.wu.s  "FP Convert Float to Word Unsigned (SP)"         "frm ← rm ; if f32(frs1) > 0 then rd ← u32(f32(frs1) else rd ← 0"
fcvt.s.w   "FP Convert Word to Float (SP)"                  "frm ← rm ; frd ← f32(s32(rs1))"
fcvt.s.wu  "FP Convert Word Unsigned to Float (SP)"         "frm ← rm ; frd ← f32(u32(rs1))"
fmv.x.s    "FP Move to Integer Register (SP)"               "rd ← s32(frs1)"
fclass.s   "FP Classify (SP)"                               "rd ← f32_classify(f32(frs1))"
fmv.s.x    "FP Move from Integer Register (SP)"             "frd ← s32(rs1)"

# RV64F    "RV64F Standard Extension for Single-Precision Floating-Point (in addition to RV32F)"

fcvt.l.s   "FP Convert Float to Double Word (SP)"           "rd ← s64(f32(frs1))"
fcvt.lu.s  "FP Convert Float to Double Word Unsigned (SP)"  "rd ← u64(f32(frs1))"
fcvt.s.l   "FP Convert Double Word to Float (SP)"           "frd ← f32(s64(rs1))"
fcvt.s.lu  "FP Convert Double Word Unsigned to Float (SP)"  "frd ← f32(u64(rs1))"

# RV32D    "RV32D Standard Extension for Double-Precision Floating-Point"

fld        "FP Load (DP)"                                   "frd ← f64[rs1 + imm]"
fsd        "FP Store (DP)"                                  "f64[rs1 + imm] ← f64(frs2)"
fmadd.d    "FP Fused Multiply Add (DP)"                     "frm ← rm ; frd ← f64(frs1) × f64(frs2) + f64(frs3)"
fmsub.d    "FP Fused Multiply Subtract (DP)"                "frm ← rm ; frd ← f64(frs1) × f64(frs2) - f64(frs3)"
fnmadd.d   "FP Negate fused Multiply Add (DP)"              "frm ← rm ; frd ← -(f64(frs1) × f64(frs2) + f64(frs3))"
fnmsub.d   "FP Negate fused Multiply Subtract (DP)"         "frm ← rm ; frd ← -(f64(frs1) × f64(frs2) - f64(frs3))"
fadd.d     "FP Add (DP)"                                    "frm ← rm ; frd ← f64(frs1) + f64(frs2)"
fsub.d     "FP Subtract (DP)"                               "frm ← rm ; frd ← f64(frs1) - f64(frs2)"
fmul.d     "FP Multiply (DP)"                               "frm ← rm ; frd ← f64(frs1) × f64(frs2)"
fdiv.d     "FP Divide (DP)"                                 "frm ← rm ; frd ← f64(frs1) ÷ f64(frs2)"
fsgnj.d    "FP to Sign-injection (DP)"                      "frd ← f64_copysign(f64(frs1), f64(frs2))"
fsgnjn.d   "FP to Sign-injection Negate (DP)"               "frd ← f64_copysign(f64(frs1), -f64(frs2))"
fsgnjx.d   "FP to Sign-injection Xor (DP)"                  "frd ← f64_xorsign(f64(frs1), f64(frs2))"
fmin.d     "FP Minimum (DP)"                                "frd ← f64_min(f64(frs1), f64(frs2))"
fmax.d     "FP Maximum (DP)"                                "frd ← f64_max(f64(frs1), f64(frs2))"
fcvt.s.d   "FP Convert DP to SP"                            "frm ← rm ; frd ← f32(f64(frs1))"
fcvt.d.s   "FP Convert SP to DP"                            "frm ← rm ; frd ← f64(f32(frs1))"
fsqrt.d    "Floating Square Root (DP)"                      "frm ← rm ; frd ← f64_sqrt(f64(frs1))"
fle.d      "FP Less Than Equal (DP)"                        "if f64(frs1) ≤ f64(frs2) then rd ← 1 else rd ← 0"
flt.d      "FP Less Than (DP)"                              "if f64(frs1) < f64(frs2) then rd ← 1 else rd ← 0"
feq.d      "FP Equal (DP)"                                  "if f64(frs1) = f64(frs2) then rd ← 1 else rd ← 0"
fcvt.w.d   "FP Convert Float to Word (DP)"                  "frm ← rm ; rd ← s32(f64(frs1))"
fcvt.wu.d  "FP Convert Float to Word Unsigned (DP)"         "frm ← rm ; if f32(frs1) > 0 then rd ← u32(f64(frs1) else rd ← 0"
fcvt.d.w   "FP Convert Word to Float (DP)"                  "frm ← rm ; frd ← f64(s32(rs1))"
fcvt.d.wu  "FP Convert Word Unsigned to Float (DP)"         "frm ← rm ; frd ← f64(u32(rs1))"
fclass.d   "FP Classify (DP)"                               "rd ← rd ← f64_classify(f64(frs1))"

# RV64D    "RV64D Standard Extension for Double-Precision Floating-Point (in addition to RV32F)"

fcvt.l.d   "FP Convert Float to Double Word (DP)"           "frm ← rm ; rd ← s64(f64(frs1))"
fcvt.lu.d  "FP Convert Float to Double Word Unsigned (DP)"  "frm ← rm ; if f64(frs1) > 0 then rd ← u64(f64(frs1) else rd ← 0"
fmv.x.d    "FP Move to Integer Register (DP)"               "rd ← s64(frs1)"
fcvt.d.l   "FP Convert Double Word to Float (DP)"           "frm ← rm ; frd ← f64(u64(rs1))"
fcvt.d.lu  "FP Convert Double Word Unsigned Float (DP)"     "frm ← rm ; frd ← f64(s64(rs1))"
fmv.d.x    "FP Move from Integer Register (DP)"             "frd ← u64(rs1)"

# RV32FD   "RV32F and RV32D Common Floating-Point Instructions"

frcsr      "Read FP control and status register"
frrm       "Read FP Rounding Mode"
frflags    "Read FP Accrued Exception Flags"
fscsr      "Set FP control and status register"
fsrm       "Set FP Rounding Mode"
fsflags    "Set FP Accrued Exception Flags"
fsrmi      "Set FP Rounding Mode Immediate"
fsflagsi   "Set FP Accrued Exception Flags Immediate"
