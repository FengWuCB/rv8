# format of a line in this file:
# <instruction name> "<instruction description>"

# RV32I    "RV32I Base Integer Instruction Set"

lui        "Set and sign extend the 20-bit immediate (shited 12 bits left) and zero the bottom 12 bits into rd" 
auipc      "Place the PC plus the 20-bit signed immediate (shited 12 bits left) into rd (used before JALR)"
jal        "Jump to the PC plus 20-bit signed immediate while saving PC+4 into rd"
jalr       "Jump to rs1 plus the 12-bit signed immediate while saving PC+4 into rd"
beq        "Branch to PC relative 12-bit signed immediate (shifted 1 bit left) if rs1 == rs2"
bne        "Branch to PC relative 12-bit signed immediate (shifted 1 bit left) if rs1 != rs2"
blt        "Branch to PC relative 12-bit signed immediate (shifted 1 bit left) if rs1 < rs2 (signed)"
bge        "Branch to PC relative 12-bit signed immediate (shifted 1 bit left) if rs1 >= rs2 (signed)"
bltu       "Branch to PC relative 12-bit signed immediate (shifted 1 bit left) if rs1 < rs2 (unsigned)"
bgeu       "Branch to PC relative 12-bit signed immediate (shifted 1 bit left) if rs1 >= rs2 (unsigned)"
lb         "Load 8-bit value from addr in rs1 plus the 12-bit signed immediate and place sign-extended result into rd"
lh         "Load 16-bit value from addr in rs1 plus the 12-bit signed immediate and place sign-extended result into rd"
lw         "Load 32-bit value from addr in rs1 plus the 12-bit signed immediate and place sign-extended result into rd"
lbu        "Load 8-bit value from addr in rs1 plus the 12-bit signed immediate and place zero-extended result into rd"
lhu        "Load 32-bit value from addr in rs1 plus the 12-bit signed immediate and place zero-extended result into rd"
lwu        "Load 32-bit value from addr in rs1 plus the 12-bit signed immediate and place zero-extended result into rd"
sb         "Store 8-bit value from the low bits of rs2 to addr in rs1 plus the 12-bit signed immediate"
sh         "Store 16-bit value from the low bits of rs2 to addr in rs1 plus the 12-bit signed immediate"
sw         "Store 32-bit value from the low bits of rs2 to addr in rs1 plus the 12-bit signed immediate"
addi       "Add sign-extended 12-bit immediate to register rs1 and place the result in rd"
slti       "Set rd to 1 if rs1 is less than the sign-extended 12-bit immediate, otherwise set rd to 0 (signed)"
sltiu      "Set rd to 1 if rs1 is less than the sign-extended 12-bit immediate, otherwise set rd to 0 (unsigned)"
xori       "Set rd to the bitwise xor of rs1 with the sign-extended 12-bit immediate"
ori        "Set rd to the bitwise or of rs1 with the sign-extended 12-bit immediate"
andi       "Set rd to the bitwise and of rs1 with the sign-extended 12-bit immediate"
slli       "Shift rs1 left by the 5 or 6 (RV32/64) bit (RV64) immediate and place the result into rd"
srli       "Shift rs1 right by the 5 or 6 (RV32/64) bit immediate and place the result into rd"
srai       "Shift rs1 right by the 5 or 6 (RV32/64) bit immediate and place the result into rd while retaining the sign"
add        "Add rs2 to rs1 and place the result into rd"
sub        "Subtract rs2 from rs1 and place the result into rd"
sll        "Shift rs1 left by the by the lower 5 or 6 (RV32/64) bits in rs2 and place the result into rd"
slt        "Set rd to 1 if rs1 is less than rs2, otherwise set rd to 0 (signed)"
sltu       "Set rd to 1 if rs1 is less than rs2, otherwise set rd to 0 (unsigned)"
xor        "Set rd to the bitwise xor of rs1 and rs2"
srl        "Shift rs1 right by the by the lower 5 or 6 (RV32/64) bits in rs2 and place the result into rd"
sra        "Shift rs1 right by the by the lower 5 or 6 (RV32/64) bits in rs2 and place the result into rd while retaining the sign"
or         "Set rd to the bitwise or of rs1 and rs2"
and        "Set rd to the bitwise and of rs1 and rs2"
fence      "Order device I/O and memory accesses viewed by other threads and devices"
fence.i    "Synchronize the instruction and data streams"

# RV64I    "RV64I Base Integer Instruction Set (in addition to RV32I)"

ld         "Load 64-bit value from addr in rs1 plus 12-bit signed immediate and place sign-extended result into rd"
sd         "Store 64-bit value from the low bits of rs2 to addr in rs1 plus the 12-bit signed immediate"
addiw      "Add sign-extended 12-bit immediate to register rs1 and place 32-bit sign extended result in rs2 zeroing upper bits"
slliw      "Shift 32-bit value in rs1 left by the 5 bit immediate and place the result into rd while zeroing upper bits"
srliw      "Shift 32-bit value in rs1 right by the 5 bit immediate and place the result into rd while zeroing upper bits"
sraiw      "Shift 32-bit value in rs1 right by the 5 bit immediate and place the result into rd and retaining the sign"
addw       "Add 32-bit value in rs2 to rs1 and place the 32-bit result into rd"
subw       "Subtract 32-bit value in rs2 from rs1 and place the 32-bit result into rd"
sllw       "Shift 32-bit value in rs1 left by the by the lower 5 bits in rs2 and place the 32-bit result into rd"
srlw       "Shift 32-bit value in rs1 right by the by the lower 5 bits in rs2 and place the 32-bit result into rd"
sraw       "Shift 32-bit value in rs1 right by the by the lower 5 bits in rs2 and place the 32-bit result into rd while retaining the sign"

# RV32M    "RV32M Standard Extension for Integer Multiply and Divide"

mul        "Multiply rs1 by rs2 and place the result in rd"
mulh       "Multiply signed rs1 by signed rs2 and place the high bits of the result in rd"
mulhsu     "Multiply signed rs1 by unsigned rs2 and place the high bits of the result in rd"
mulhu      "Multiply unsigned rs1 by unsigned rs2 and place the high bits of the result in rd"
div        "Divide rs1 (dividend) by rs2 (divisor) and place the quotient in rd (signed)"
divu       "Divide rs1 (dividend) by rs2 (divisor) and place the quotient in rd (unsigned)"
rem        "Divide rs1 (dividend) by rs2 (divisor) and place the remainder in rd (signed)"
remu       "Divide rs1 (dividend) by rs2 (divisor) and place the remainder in rd (unsigned)"

# RV64M    "RV64M Standard Extension for Integer Multiply and Divide (in addition to RV32M)"

mulw       "Multiply with lower 32-bits of rs1 by the lower 32-bits of rs2 and place the result in rd"
divw       "Divide lower 32-bits of rs1 (dividend) by lower 32-bits of rs2 (divisor) and place the quotient in rd (signed)"
divuw      "Divide lower 32-bits of rs1 (dividend) by lower 32-bits of rs2 (divisor) and place the quotient in rd (unsigned)"
remw       "Divide lower 32-bits of rs1 (dividend) by lower 32-bits of rs2 (divisor) and place the remainder in rd (signed)"
remuw      "Divide lower 32-bits of rs1 (dividend) by lower 32-bits of rs2 (divisor) and place the remainder in rd (unsigned)"

# RV32A    "RV32A Standard Extension for Atomic Instructions"

lr.w       "Load word from address in rs1, place the sign-extended result in rd and register a reservation on the memory word"
sc.w       "Write word in rs1 to the address in rs2 if a valid reservation exists, write 0 on success or 1 on failure to rd"
amoswap.w  "Load word from address in rs1 into rd, swap rd and rs2, write the result to the address in rs1"
amoadd.w   "Load word from address in rs1 into rd, add rd and rs2, write the result to the address in rs1"
amoxor.w   "Load word from address in rs1 into rd, xor rd and rs2, write the result to the address in rs1"
amoor.w    "Load word from address in rs1 into rd, or rd and rs2, write the result to the address in rs1"
amoand.w   "Load word from address in rs1 into rd, and rd and rs2, write the result to the address in rs1"
amomin.w   "Load word from address in rs1 into rd, find minimum of rd and rs2, write the result to the address in rs1 (signed)"
amomax.w   "Load word from address in rs1 into rd, find maximum of rd and rs2, write the result to the address in rs1 (signed)"
amominu.w  "Load word from address in rs1 into rd, find minimum of rd and rs2, write the result to the address in rs1 (unsigned)"
amomaxu.w  "Load word from address in rs1 into rd, find maximum of rd and rs2, write the result to the address in rs1 (unsigned)"

# RV64A    "RV64A Standard Extension for Atomic Instructions (in addition to RV32A)"

lr.d       "Load double word from address in rs1, place the sign-extended result in rd and register a reservation on the memory word"
sc.d       "Write double word in rs1 to the address in rs2 if a valid reservation exists, write 0 on success or 1 on failure to rd"
amoswap.d  "Load double word from address in rs1 into rd, swap rd and rs2, write the result to the address in rs1"
amoadd.d   "Load double word from address in rs1 into rd, add rd and rs2, write the result to the address in rs1"
amoxor.d   "Load double word from address in rs1 into rd, xor rd and rs2, write the result to the address in rs1"
amoor.d    "Load double word from address in rs1 into rd, or rd and rs2, write the result to the address in rs1"
amoand.d   "Load double word from address in rs1 into rd, and rd and rs2, write the result to the address in rs1"
amomin.d   "Load double word from address in rs1 into rd, find minimum of rd and rs2, write the result to the address in rs1 (signed)"
amomax.d   "Load double word from address in rs1 into rd, find maximum of rd and rs2, write the result to the address in rs1 (signed)"
amominu.d  "Load double word from address in rs1 into rd, find minimum of rd and rs2, write the result to the address in rs1 (unsigned)"
amomaxu.d  "Load double word from address in rs1 into rd, find maximum of rd and rs2, write the result to the address in rs1 (unsigned)"

# RV32S    "RV32S Standard Extension for Supervisor-level Instructions"

scall      "System call is used to make a request to a higher privilege level"
sbreak     "Break to Debugger causes control to be transferred back to the debugging environment via a breakpoint exception"
sret       "System Return returns to the supervisor mode privilege level after handling a trap"
sfence.vm  "Supervisor memory-management fence synchronizes updates to in-memory memory-management data structures"
wfi        "Wait for Interrupt indicates the hart can be stalled until an interrupt needs servicing"
mrth       "-Machine Redirect Trap to Hypervisor"
mrts       "-Machine Redirect Trap to Supervisor"
hrts       "-Hypervisor Redirect Trap to Supervisor"
rdcycle    "-Read Cycle Counter"
rdtime     "-Read Timer"
rdinstret  "-Read Instructions Retired"
rdcycleh   "-Read Cycle Counter (Upper 32-bits)"
rdtimeh    "-Read Timer (Upper 32-bits)"
rdinstreth "-Read Instructions Retired (Upper 32-bits)"
csrrw      "CSR Atomic Read Write writes the value in rs1 to the CSR, and writes previous value to rd
csrrs      "CSR Atomic Set Bit reads the CSR, sets CSR bits set in rs1, and writes previous value to rd"
csrrc      "CSR Atomic Clear Bit reads the CSR, clears CSR bits set in rs1, and writes previous value to rd
csrrwi     "CSR Atomic Read Write Immediate writes the immediate value to the CSR, and writes previous value to rd"
csrrsi     "CSR Atomic Set Bit Immediate reads the CSR, sets CSR bits set in the immediate, and writes previous value to rd
csrrci     "CSR Atomic Clear Bit Immediate reads the CSR, clears CSR bits set in the immediate, and writes previous value to rd"

# RV32F    "RV32F Standard Extension for Single-Precision Floating-Point"

flw        "Loads a single-precision foating-point value from memory into foating-point register frd"
fsw        "Stores a single-precision foating-point value from foating-point register frs2 to memory"
fmadd.s    "Multiply the values in frs1 and frs2, then add rs3 and write the result to frd"
fmsub.s    "Multiply the values in frs1 and frs2, then subtract rs3 and write the result to frd"
fnmsub.s   "Multiply the values in frs1 and frs2, then add rs3 and write the negated result to frd"
fnmadd.s   "Multiply the values in frs1 and frs2, then subtract rs3 and write the negated result to frd"
fadd.s     "Add the values in frs1 and frs2, then write the result to frd"
fsub.s     "Subtract the values in frs1 from frs2, then write the result to frd"
fmul.s     "Multiply the values in frs1 and frs2, then write the result to frd"
fdiv.s     "Divide the value in frs1 into frs2, then write the result to frd"
fsgnj.s    "Take the value from frs1 and inject the sign bit from frs2, then write the result to frd"
fsgnjn.s   "Take the value from frs1 and inject the negated sign bit from frs2, then write the result to frd"
fsgnjx.s   "Take the value from frs1 and inject the xor of the sign bits frs1 and frs2, then write the result to frd"
fmin.s     "Take the smaller value from frs1 and frs2, then write the result to frd"
fmax.s     "Take the larger value from frs1 and frs2, then write the result to frd"
fsqrt.s    "Calculate the square root of frs1, then write the result to frd"
fle.s      "-FP Less Than Equal (SP)"
flt.s      "-FP Less Than (SP)"
feq.s      "-FP Equal (SP)"
fcvt.w.s   "-FP Convert Float to Word (SP)"
fcvt.wu.s  "-FP Convert Float to Word Unsigned (SP)"
fcvt.s.w   "-FP Convert Word to Float (SP)"
fcvt.s.wu  "-FP Convert Word Unsigned to Float (SP)"
fclass.s   "-FP Classify (SP)"

# RV64F    "RV64F Standard Extension for Single-Precision Floating-Point (in addition to RV32F)"

fcvt.l.s   "-FP Convert Float to Double Word (SP)"
fcvt.lu.s  "-FP Convert Float to Double Word Unsigned (SP)"
fmv.x.s    "-FP Move to Integer Register (SP)"
fcvt.s.l   "-FP Convert Double Word to Float (SP)"
fcvt.s.lu  "-FP Convert Double Word Unsigned to Float (SP)"
fmv.s.x    "-FP Move from Integer Register (SP)"

# RV32D    "RV32D Standard Extension for Double-Precision Floating-Point"

fld        "-FP Load (DP)"
fsd        "-FP Store (DP)"
fmadd.d    "-FP Fused Multiply Add (DP)"
fmsub.d    "-FP Fused Multiply Subtract (DP)"
fnmsub.d   "-FP Negate fused Multiply Add (DP)"
fnmadd.d   "-FP Negate fused Multiply Subtract (DP)"
fadd.d     "-FP Add (DP)"
fsub.d     "-FP Subtract (DP)"
fmul.d     "-FP Multiply (DP)"
fdiv.d     "-FP Divide (DP)"
fsgnj.d    "-FP to Sign-injection (DP)"
fsgnjn.d   "-FP to Sign-injection Negate (DP)"
fsgnjx.d   "-FP to Sign-injection Xor (DP)"
fmin.d     "-FP Minimum (DP)"
fmax.d     "-FP Maximum (DP)"
fcvt.s.d   "-FP Convert DP to SP"
fcvt.d.s   "-FP Convert SP to DP"
fsqrt.d    "-Floating Square Root (DP)"
fle.d      "-FP Less Than Equal (DP)"
flt.d      "-FP Less Than (DP)"
feq.d      "-FP Equal (DP)"
fcvt.w.d   "-FP Convert Float to Word (DP)"
fcvt.wu.d  "-FP Convert Float to Word Unsigned (DP)"
fcvt.d.w   "-FP Convert Word to Float (DP)"
fcvt.d.wu  "-FP Convert Word Unsigned to Float (DP)"
fmv.x.d    "-FP Move to Integer Register (DP)"
fclass.d   "-FP Classify (DP)"
fmv.d.x    "-FP Move from Integer Register (DP)"

# RV64D    "RV64D Standard Extension for Double-Precision Floating-Point (in addition to RV32F)"

fcvt.l.d   "-FP Convert Float to Double Word (DP)"
fcvt.lu.d  "-FP Convert Float to Double Word Unsigned (DP)"
fcvt.d.l   "-FP Convert Double Word to Float (DP)"
fcvt.d.lu  "-FP Convert Double Word Unsigned Float (DP)"

# RV32FD   "RV32F and RV32D Common Floating-Point Instructions"

frcsr      "-Read FP control and status register"
frrm       "-Read FP Rounding Mode"
frflags    "-Read FP Accrued Exception Flags"
fscsr      "-Set FP control and status register"
fsrm       "-Set FP Rounding Mode"
fsflags    "-Set FP Accrued Exception Flags"
fsrmi      "-Set FP Rounding Mode Immediate"
fsflagsi   "-Set FP Accrued Exception Flags Immediate"
