# format of a line in this file:
# <instruction name> "<instruction long name>" "<instruction description>"

# RV32I    "RV32I Base Integer Instruction Set"

lui        "Load Upper Immediate"                           "Set and sign extend the 20-bit immediate (shited 12 bits left) and zero the bottom 12 bits into rd" 
auipc      "Add Upper Immediate to PC                       "Place the PC plus the 20-bit signed immediate (shited 12 bits left) into rd (used before JALR)"
jal        "Jump and Link"                                  "Jump to the PC plus 20-bit signed immediate while saving PC+4 into rd"
jalr       "Jump and Link Register"                         "Jump to rs1 plus the 12-bit signed immediate while saving PC+4 into rd"
beq        "Branch Equal"                                   "Branch to PC relative 12-bit signed immediate (shifted 1 bit left) if rs1 == rs2"
bne        "Branch Not Equal"                               "Branch to PC relative 12-bit signed immediate (shifted 1 bit left) if rs1 != rs2"
blt        "Branch Less Than "                              "Branch to PC relative 12-bit signed immediate (shifted 1 bit left) if rs1 < rs2 (signed)"
bge        "Branch Greater than Equal"                      "Branch to PC relative 12-bit signed immediate (shifted 1 bit left) if rs1 >= rs2 (signed)"
bltu       "Branch Less Than Unsigned"                      "Branch to PC relative 12-bit signed immediate (shifted 1 bit left) if rs1 < rs2 (unsigned)"
bgeu       "Branch Greater than Equal Unsigned"             "Branch to PC relative 12-bit signed immediate (shifted 1 bit left) if rs1 >= rs2 (unsigned)"
lb         "Load Byte"                                      "Load 8-bit value from addr in rs1 plus the 12-bit signed immediate and place sign-extended result into rd"
lh         "Load Half"                                      "Load 16-bit value from addr in rs1 plus the 12-bit signed immediate and place sign-extended result into rd"
lw         "Load Word"                                      "Load 32-bit value from addr in rs1 plus the 12-bit signed immediate and place sign-extended result into rd"
lbu        "Load Byte Unsigned"                             "Load 8-bit value from addr in rs1 plus the 12-bit signed immediate and place zero-extended result into rd"
lhu        "Load Half Unsigned"                             "Load 32-bit value from addr in rs1 plus the 12-bit signed immediate and place zero-extended result into rd"
lwu        "Load Word Unsigned"                             "Load 32-bit value from addr in rs1 plus the 12-bit signed immediate and place zero-extended result into rd"
sb         "Store Byte"                                     "Store 8-bit value from the low bits of rs2 to addr in rs1 plus the 12-bit signed immediate"
sh         "Store Half"                                     "Store 16-bit value from the low bits of rs2 to addr in rs1 plus the 12-bit signed immediate"
sw         "Store Word"                                     "Store 32-bit value from the low bits of rs2 to addr in rs1 plus the 12-bit signed immediate"
addi       "Add Immediate"                                  "Add sign-extended 12-bit immediate to register rs1 and place the result in rs2"
slti       "Set Less Than Immediate"                        "Set rd to 1 if rs1 is less than the sign-extended 12-bit immediate, otherwise set rd to 0 (signed)"
sltiu      "Set Less Than Immediate Unsigned"               "Set rd to 1 if rs1 is less than the sign-extended 12-bit immediate, otherwise set rd to 0 (unsigned)"
xori       "Xor Immediate"                                  "Set rd to the bitwise xor of rs1 with the sign-extended 12-bit immediate"
ori        "Or Immediate"                                   "Set rd to the bitwise or of rs1 with the sign-extended 12-bit immediate"
andi       "And Immediate"                                  "Set rd to the bitwise and of rs1 with the sign-extended 12-bit immediate"
slli       "Shift Left Logical Immediate"                   "Shift rs1 left by the 5 or 6 (RV32/64) bit (RV64) immediate and place the result into rd"
srli       "Shift Right Logical Immediate"                  "Shift rs1 right by the 5 or 6 (RV32/64) bit immediate and place the result into rd"
srai       "Shift Right Arithmetic Immediate"               "Shift rs1 right by the 5 or 6 (RV32/64) bit immediate and place the result into rd while retaining the sign"
add        "Add"                                            "Add rs2 to rs1 and place the result into rd"
sub        "Subtract"                                       "Subtract rs2 from rs1 and place the result into rd"
sll        "Shift Left Logical"                             "Shift rs1 left by the by the lower 5 or 6 (RV32/64) bits in rs2 and place the result into rd"
slt        "Set Less Than"                                  "Set rd to 1 if rs1 is less than rs2, otherwise set rd to 0 (signed)"
sltu       "Set Less Than Unsigned"                         "Set rd to 1 if rs1 is less than rs2, otherwise set rd to 0 (unsigned)"
xor        "Xor"                                            "Set rd to the bitwise xor of rs1 and rs2"
srl        "Shift Right Logical"                            "Shift rs1 right by the by the lower 5 or 6 (RV32/64) bits in rs2 and place the result into rd"
sra        "Shift Right Arithmetic"                         "Shift rs1 right by the by the lower 5 or 6 (RV32/64) bits in rs2 and place the result into rd while retaining the sign"
or         "Or"                                             "Set rd to the bitwise or of rs1 and rs2"
and        "And"                                            "Set rd to the bitwise and of rs1 and rs2"
fence      "Fence"                                          "Order device I/O and memory accesses viewed by other threads and devices"
fence.i    "Fence Instruction"                              "Synchronize the instruction and data streams"

# RV64I    "RV64I Base Integer Instruction Set (in addition to RV32I)"

ld         "Load Double"                                    "Load 64-bit value from addr in rs1 plus 12-bit signed immediate and place sign-extended result into rd"
sd         "Store Double"                                   "Store 64-bit value from the low bits of rs2 to addr in rs1 plus the 12-bit signed immediate"
addiw      "Add Immediate Word"                             "Add sign-extended 12-bit immediate to register rs1 and place 32-bit sign extended result in rs2 zeroing upper bits"
slliw      "Shift Left Logical Immediate Word"              "Shift 32-bit value in rs1 left by the 5 bit immediate and place the result into rd while zeroing upper bits"
srliw      "Shift Right Logical Immediate Word"             "Shift 32-bit value in rs1 right by the 5 bit immediate and place the result into rd while zeroing upper bits"
sraiw      "Shift Right Arithmetic Immediate Word"          "Shift 32-bit value in rs1 right by the 5 bit immediate and place the result into rd and retaining the sign"
addw       "Add Word"                                       "Add 32-bit value in rs2 to rs1 and place the 32-bit result into rd"
subw       "Subtract Word"                                  "Subtract 32-bit value in rs2 from rs1 and place the 32-bit result into rd"
sllw       "Shift Left Logical Word"                        "Shift 32-bit value in rs1 left by the by the lower 5 bits in rs2 and place the 32-bit result into rd"
srlw       "Shift Right Logical Word"                       "Shift 32-bit value in rs1 right by the by the lower 5 bits in rs2 and place the 32-bit result into rd"
sraw       "Shift Right Arithmetic Word"                    "Shift 32-bit value in rs1 right by the by the lower 5 bits in rs2 and place the 32-bit result into rd while retaining the sign"

# RV32M    "RV32M Standard Extension for Integer Multiply and Divide"

mul        "Multiply"                                       "Multiply rs1 by rs2 and place the result in rd"
mulh       "Multiply High Signed Signed"                    "Multiply signed rs1 by signed rs2 and place the high bits of the result in rd"
mulhsu     "Multiply High Signed Unsigned"                  "Multiply signed rs1 by unsigned rs2 and place the high bits of the result in rd"
mulhu      "Multiply High Unsigned Unsigned"                "Multiply unsigned rs1 by unsigned rs2 and place the high bits of the result in rd"
div        "Divide Signed"                                  "Divide rs1 (dividend) by rs2 (divisor) and place the quotient in rd (signed)"
divu       "Divide Unsigned"                                "Divide rs1 (dividend) by rs2 (divisor) and place the quotient in rd (unsigned)"
rem        "Remainder Signed"                               "Divide rs1 (dividend) by rs2 (divisor) and place the remainder in rd (signed)"
remu       "Remainder Unsigned"                             "Divide rs1 (dividend) by rs2 (divisor) and place the remainder in rd (unsigned)"

# RV64M    "RV64M Standard Extension for Integer Multiply and Divide (in addition to RV32M)"

mulw       "Multiple Word"                                  "Multiply with lower 32-bits of rs1 by the lower 32-bits of rs2 and place the result in rd"
divw       "Divide Signed Word"                             "Divide lower 32-bits of rs1 (dividend) by lower 32-bits of rs2 (divisor) and place the quotient in rd (signed)"
divuw      "Divide Unsigned Word"                           "Divide lower 32-bits of rs1 (dividend) by lower 32-bits of rs2 (divisor) and place the quotient in rd (unsigned)"
remw       "Remainder Signed Word"                          "Divide lower 32-bits of rs1 (dividend) by lower 32-bits of rs2 (divisor) and place the remainder in rd (signed)"
remuw      "Remainder Unsigned Word"                        "Divide lower 32-bits of rs1 (dividend) by lower 32-bits of rs2 (divisor) and place the remainder in rd (unsigned)"

# RV32A    "RV32A Standard Extension for Atomic Instructions"

lr.w       "Load Reserved Word"                             "Load word from address in rs1, place the sign-extended result in rd and register a reservation on the memory word"
sc.w       "Store Conditional Word"                         "Write word in rs1 to the address in rs2 if a valid reservation exists, write 0 on success or 1 on failure to rd"
amoswap.w  "Atomic Swap Word"                               "Load word from address in rs1 into rd, swap rd and rs2, write the result to the address in rs1"
amoadd.w   "Atomic Add Word"                                "Load word from address in rs1 into rd, add rd and rs2, write the result to the address in rs1"
amoxor.w   "Atomic Xor Word"                                "Load word from address in rs1 into rd, xor rd and rs2, write the result to the address in rs1"
amoor.w    "Atomic Or Word"                                 "Load word from address in rs1 into rd, or rd and rs2, write the result to the address in rs1"
amoand.w   "Atomic And Word"                                "Load word from address in rs1 into rd, and rd and rs2, write the result to the address in rs1"
amomin.w   "Atomic Minimum Word"                            "Load word from address in rs1 into rd, find minimum of rd and rs2, write the result to the address in rs1 (signed)"
amomax.w   "Atomic Maximum Word"                            "Load word from address in rs1 into rd, find maximum of rd and rs2, write the result to the address in rs1 (signed)"
amominu.w  "Atomic Minimum Unsigned Word"                   "Load word from address in rs1 into rd, find minimum of rd and rs2, write the result to the address in rs1 (unsigned)"
amomaxu.w  "Atomic Maximum Unsigned Word"                   "Load word from address in rs1 into rd, find maximum of rd and rs2, write the result to the address in rs1 (unsigned)"

# RV64A    "RV64A Standard Extension for Atomic Instructions (in addition to RV32A)"

lr.d       "Load Reserved Double Word"                      "Load double word from address in rs1, place the sign-extended result in rd and register a reservation on the memory word"
sc.d       "Store Conditional Double Word"                  "Write double word in rs1 to the address in rs2 if a valid reservation exists, write 0 on success or 1 on failure to rd"
amoswap.d  "Atomic Swap Double Word"                        "Load double word from address in rs1 into rd, swap rd and rs2, write the result to the address in rs1"
amoadd.d   "Atomic Add Double Word"                         "Load double word from address in rs1 into rd, add rd and rs2, write the result to the address in rs1"
amoxor.d   "Atomic Xor Double Word"                         "Load double word from address in rs1 into rd, xor rd and rs2, write the result to the address in rs1"
amoor.d    "Atomic Or Double Word"                          "Load double word from address in rs1 into rd, or rd and rs2, write the result to the address in rs1"
amoand.d   "Atomic And Double Word"                         "Load double word from address in rs1 into rd, and rd and rs2, write the result to the address in rs1"
amomin.d   "Atomic Minimum Double Word"                     "Load double word from address in rs1 into rd, find minimum of rd and rs2, write the result to the address in rs1 (signed)"
amomax.d   "Atomic Maximum Double Word"                     "Load double word from address in rs1 into rd, find maximum of rd and rs2, write the result to the address in rs1 (signed)"
amominu.d  "Atomic Minimum Unsigned Double Word"            "Load double word from address in rs1 into rd, find minimum of rd and rs2, write the result to the address in rs1 (unsigned)"
amomaxu.d  "Atomic Maximum Unsigned Double Word"            "Load double word from address in rs1 into rd, find maximum of rd and rs2, write the result to the address in rs1 (unsigned)"

# RV32S    "RV32S Standard Extension for Supervisor-level Instructions"

scall      "System Call"
sbreak     "System Break to Debugger"
sret       "System Return"
sfence.vm  "Supervisor Memory Management Fence"
wfi        "Wait For Interrupt"
mrth       "Machine Redirect Trap to Hypervisor"
mrts       "Machine Redirect Trap to Supervisor"
hrts       "Hypervisor Redirect Trap to Supervisor"
rdcycle    "Read Cycle Counter"
rdtime     "Read Timer"
rdinstret  "Read Instructions Retired"
rdcycleh   "Read Cycle Counter (Upper 32-bits)"
rdtimeh    "Read Timer (Upper 32-bits)"
rdinstreth "Read Instructions Retired (Upper 32-bits)"
csrrw      "CSR Atomic Read Write"
csrrs      "CSR Atomic Set Bit"
csrrc      "CSR Atomic Clear Bit"
csrrwi     "CSR Atomic Read Write Immediate"
csrrsi     "CSR Atomic Set Bit Immediate"
csrrci     "CSR Atomic Clear Bit Immediate"

# RV32F    "RV32F Standard Extension for Single-Precision Floating-Point"

flw        "FP Load (SP)"
fsw        "FP Store (SP)"
fmadd.s    "FP Fused Multiply Add (SP)"
fmsub.s    "FP Fused Multiply Subtract (SP)"
fnmsub.s   "FP Negate fused Multiply Add (SP)"
fnmadd.s   "FP Negate fused Multiply Subtract (SP)"
fadd.s     "FP Add (SP)"
fsub.s     "FP Subtract (SP)"
fmul.s     "FP Multiply (SP)"
fdiv.s     "FP Divide (SP)"
fsgnj.s    "FP Sign-injection (SP)"
fsgnjn.s   "FP Sign-injection Negate (SP)"
fsgnjx.s   "FP Sign-injection Xor (SP)"
fmin.s     "FP Minimum (SP)"
fmax.s     "FP Maximum (SP)"
fsqrt.s    "FP Square Root (SP)"
fle.s      "FP Less Than Equal (SP)"
flt.s      "FP Less Than (SP)"
feq.s      "FP Equal (SP)"
fcvt.w.s   "FP Convert Float to Word (SP)"
fcvt.wu.s  "FP Convert Float to Word Unsigned (SP)"
fcvt.s.w   "FP Convert Word to Float (SP)"
fcvt.s.wu  "FP Convert Word Unsigned to Float (SP)"
fmv.x.s    "FP Move to Integer Register (SP)"
fclass.s   "FP Classify (SP)"
fmv.s.x    "FP Move from Integer Register (SP)"

# RV64F    "RV64F Standard Extension for Single-Precision Floating-Point (in addition to RV32F)"

fcvt.l.s   "FP Convert Float to Double Word (SP)"
fcvt.lu.s  "FP Convert Float to Double Word Unsigned (SP)"
fcvt.s.l   "FP Convert Double Word to Float (SP)"
fcvt.s.lu  "FP Convert Double Word Unsigned to Float (SP)"

# RV32D    "RV32D Standard Extension for Double-Precision Floating-Point"

fld        "FP Load (DP)"
fsd        "FP Store (DP)"
fmadd.d    "FP Fused Multiply Add (DP)"
fmsub.d    "FP Fused Multiply Subtract (DP)"
fnmsub.d   "FP Negate fused Multiply Add (DP)"
fnmadd.d   "FP Negate fused Multiply Subtract (DP)"
fadd.d     "FP Add (DP)"
fsub.d     "FP Subtract (DP)"
fmul.d     "FP Multiply (DP)"
fdiv.d     "FP Divide (DP)"
fsgnj.d    "FP to Sign-injection (DP)"
fsgnjn.d   "FP to Sign-injection Negate (DP)"
fsgnjx.d   "FP to Sign-injection Xor (DP)"
fmin.d     "FP Minimum (DP)"
fmax.d     "FP Maximum (DP)"
fcvt.s.d   "FP Convert DP to SP"
fcvt.d.s   "FP Convert SP to DP"
fsqrt.d    "Floating Square Root (DP)"
fle.d      "FP Less Than Equal (DP)"
flt.d      "FP Less Than (DP)"
feq.d      "FP Equal (DP)"
fcvt.w.d   "FP Convert Float to Word (DP)"
fcvt.wu.d  "FP Convert Float to Word Unsigned (DP)"
fcvt.d.w   "FP Convert Word to Float (DP)"
fcvt.d.wu  "FP Convert Word Unsigned to Float (DP)"
fmv.x.d    "FP Move to Integer Register (DP)"
fclass.d   "FP Classify (DP)"
fmv.d.x    "FP Move from Integer Register (DP)"

# RV64D    "RV64D Standard Extension for Double-Precision Floating-Point (in addition to RV32F)"

fcvt.l.d   "FP Convert Float to Double Word (DP)"
fcvt.lu.d  "FP Convert Float to Double Word Unsigned (DP)"
fcvt.d.l   "FP Convert Double Word to Float (DP)"
fcvt.d.lu  "FP Convert Double Word Unsigned Float (DP)"

# RV32FD   "RV32F and RV32D Common Floating-Point Instructions"

frcsr      "Read FP control and status register"
frrm       "Read FP Rounding Mode"
frflags    "Read FP Accrued Exception Flags"
fscsr      "Set FP control and status register"
fsrm       "Set FP Rounding Mode"
fsflags    "Set FP Accrued Exception Flags"
fsrmi      "Set FP Rounding Mode Immediate"
fsflagsi   "Set FP Accrued Exception Flags Immediate"
