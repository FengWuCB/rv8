# format of a line in this file:
# <instruction name> <instruction description>

# RV32I    "RV32I Base Integer Instruction Set"

lui        "Load Upper Immediate"
auipc      "Add Upper Immediate to PC"
jal        "Jump and Link"
jalr       "Jump and Link Register"
beq        "Branch Equal"
bne        "Branch Not Equal"
blt        "Branch Less Than "
bge        "Branch Greater than Equal"
bltu       "Branch Less Than Unsigned"
bgeu       "Branch Greater than Equal"
lb         "Load Byte"
lh         "Load Half"
lw         "Load Word"
lbu        "Load Byte Unsigned"
lhu        "Load Half Unsigned"
lwu        "Load Word Unsigned"
sb         "Store Byte"
sh         "Store Half"
sw         "Store Word"
addi       "Add Immediate"
slti       "Set Less Than Immediate"
sltiu      "Set Less Than Immediate Unsigned"
xori       "Xor Immediate"
ori        "Or Immediate"
andi       "And Immediate"
slli       "Shift Left Logical Immediate"
srli       "Shift Right Logical Immediate"
srai       "Shift Right Arithmetic Immediate"
add        "Add"
sub        "Subtract"
sll        "Shift Left Logical"
slt        "Set Less Than"
sltu       "Set Less Than Unsigned"
xor        "Xor"
srl        "Shift Right Logical"
sra        "Shift Right Arithmetic"
or         "Or"
and        "And"
fence      "Fence"
fence.i    "Fence Instruction"

# RV64I    "RV64I Base Integer Instruction Set (in addition to RV32I)"

ld         "Load Double"
sd         "Store Double"
slli       "Shift Left Logical Immediate"
srli       "Shift Right Logical Immediate"
srai       "Shift Right Arithmetic Immediate"
addiw      "Add Immediate Word"
slliw      "Shift Left Logical Immediate Word"
srliw      "Shift Right Logical Immediate Word"
sraiw      "Shift Right Arithmetic Immediate Word"
addw       "Add Word"
subw       "Subtract Word"
sllw       "Shift Left Logical Word"
srlw       "Shift Right Logical Word"
sraw       "Shift Right Arithmetic Word"

# RV32M    "RV32M Standard Extension for Integer Multiply and Divide"

mul        "Multiply"
mulh       "Multiply High Signed Signed"
mulhsu     "Multiply High Signed Unsigned"
mulhu      "Multiply High Unsigned Unsigned"
div        "Divide Signed"
divu       "Divide Unsigned"
rem        "Remainder Signed"
remu       "Remainder Unsigned"

# RV64M    "RV64M Standard Extension for Integer Multiply and Divide (in addition to RV32M)"

mulw       "Multiple Word"
divw       "Divide Signed Word"
divuw      "Divide Unsigned Word"
remw       "Remainder Signed Word"
remuw      "Remainder Unsigned Word"

# RV32A    "RV32A Standard Extension for Atomic Instructions"

lr.w       "Load Reserved Word"
sc.w       "Store Conditional Word"
amoswap.w  "Atomic Swap Word"
amoadd.w   "Atomic Add Word"
amoxor.w   "Atomic Xor Word"
amoor.w    "Atomic Or Word"
amoand.w   "Atomic And Word"
amomin.w   "Atomic Minimum Word"
amomax.w   "Atomic Maximum Word"
amominu.w  "Atomic Minimum Unsigned Word"
amomaxu.w  "Atomic Maximum Unsigned Word"

# RV64A    "RV64A Standard Extension for Atomic Instructions (in addition to RV32A)"

lr.d       "Load Reserved Double Word"
sc.d       "Store Conditional Double Word"
amoswap.d  "Atomic Swap Double Word"
amoadd.d   "Atomic Add Double Word"
amoxor.d   "Atomic Xor Double Word"
amoor.d    "Atomic Or Double Word"
amoand.d   "Atomic And Double Word"
amomin.d   "Atomic Minimum Double Word"
amomax.d   "Atomic Maximum Double Word"
amominu.d  "Atomic Minimum Unsigned Double Word"
amomaxu.d  "Atomic Maximum Unsigned Double Word"

# RV32S    "RV32S Standard Extension for Supervisor-level Instructions"

scall      "System Call"
sbreak     "System Break to Debugger"
sret       "System Return"
sfence.vm  "Supervisor Memory Management Fence"
wfi        "Wait For Interrupt"
mrth       "Machine Redirect Trap to Hypervisor"
mrts       "Machine Redirect Trap to Supervisor"
hrts       "Hypervisor Redirect Trap to Supervisor"
rdcycle    "Read Cycle Counter"
rdtime     "Read Timer"
rdinstret  "Read Instructions Retired"
rdcycleh   "Read Cycle Counter (Upper 32-bits)"
rdtimeh    "Read Timer (Upper 32-bits)"
rdinstreth "Read Instructions Retired (Upper 32-bits)"
csrrw      "CSR Atomic Read Write"
csrrs      "CSR Atomic Set Bit"
csrrc      "CSR Atomic Clear Bit"
csrrwi     "CSR Atomic Read Write Immediate"
csrrsi     "CSR Atomic Set Bit Immediate"
csrrci     "CSR Atomic Clear Bit Immediate"

# RV32F    "RV32F Standard Extension for Single-Precision Floating-Point"

flw        "Floating Point Load (Single-Precision)"
fsw        "Floating Point Store (Single-Precision)"
fmadd.s    "Floating Point fused Multiply Add (Single-Precision)"
fmsub.s    "Floating Point fused Multiply Subtract (Single-Precision)"
fnmsub.s   "Floating Point Negate fused Multiply Add (Single-Precision)"
fnmadd.s   "Floating Point Negate fused Multiply Subtract (Single-Precision)"
fadd.s     "Floating Point Add (Single-Precision)"
fsub.s     "Floating Point Subtract (Single-Precision)"
fmul.s     "Floating Point Multiply (Single-Precision)"
fdiv.s     "Floating Point Divide (Single-Precision)"
fsgnj.s    "Floating Point to Floating Point Sign-injection (Single-Precision)"
fsgnjn.s   "Floating Point to Floating Point Sign-injection Negate (Single-Precision)"
fsgnjx.s   "Floating Point to Floating Point Sign-injection Xor (Single-Precision)"
fmin.s     "Floating Point Minimum (Single-Precision)"
fmax.s     "Floating Point Maximum (Single-Precision)"
fsqrt.s    "Floating Square Root (Single-Precision)"
fle.s      "Floating Point Less Than Equal (Single-Precision)"
flt.s      "Floating Point Less Than (Single-Precision)"
feq.s      "Floating Point Equal (Single-Precision)"
fcvt.w.s   "Floating Point Convert to Word (Single-Precision)"
fcvt.wu.s  "Floating Point Convert to Word Unsigned (Single-Precision)"
fcvt.s.w   "Floating Point Convert from Word (Single-Precision)"
fcvt.s.wu  "Floating Point Convert from Word Unsigned (Single-Precision)"
fmv.x.s    "Floating Point Move to Integer Register (Single-Precision)"
fclass.s   "Floating Point Classify (Single-Precision)"
fmv.s.x    "Floating Point Move from Integer Register (Single-Precision)"

# RV64F    "RV64F Standard Extension for Single-Precision Floating-Point (in addition to RV32F)"

fcvt.l.s   "Floating Point Convert to Double Word (Single-Precision)"
fcvt.lu.s  "Floating Point Convert to Double Word Unsigned (Single-Precision)"
fcvt.s.l   "Floating Point Convert from Double Word (Single-Precision)"
fcvt.s.lu  "Floating Point Convert from Double Word Unsigned (Single-Precision)"

# RV32D    "RV32D Standard Extension for Double-Precision Floating-Point"

fld        "Floating Point Load (Double-Precision)"
fsd        "Floating Point Store (Double-Precision)"
fmadd.d    "Floating Point fused Multiply Add (Double-Precision)"
fmsub.d    "Floating Point fused Multiply Subtract (Double-Precision)"
fnmsub.d   "Floating Point Negate fused Multiply Add (Double-Precision)"
fnmadd.d   "Floating Point Negate fused Multiply Subtract (Double-Precision)"
fadd.d     "Floating Point Add (Double-Precision)"
fsub.d     "Floating Point Subtract (Double-Precision)"
fmul.d     "Floating Point Multiply (Double-Precision)"
fdiv.d     "Floating Point Divide (Double-Precision)"
fsgnj.d    "Floating Point to Floating Point Sign-injection (Double-Precision)"
fsgnjn.d   "Floating Point to Floating Point Sign-injection Negate (Double-Precision)"
fsgnjx.d   "Floating Point to Floating Point Sign-injection Xor (Double-Precision)"
fmin.d     "Floating Point Minimum (Double-Precision)"
fmax.d     "Floating Point Maximum (Double-Precision)"
fcvt.s.d   "Floating Point Convert Single-Precision to Double-Precision"
fcvt.d.s   "Floating Point Convert Double-Precision to Single-Precision"
fsqrt.d    "Floating Square Root (Double-Precision)"
fle.d      "Floating Point Less Than Equal (Double-Precision)"
flt.d      "Floating Point Less Than (Double-Precision)"
feq.d      "Floating Point Equal (Double-Precision)"
fcvt.w.d   "Floating Point Convert to Word (Double-Precision)"
fcvt.wu.d  "Floating Point Convert to Word Unsigned (Double-Precision)"
fcvt.d.w   "Floating Point Convert from Word (Double-Precision)"
fcvt.d.wu  "Floating Point Convert from Word Unsigned (Double-Precision)"
fmv.x.d    "Floating Point Move to Integer Register (Double-Precision)"
fclass.d   "Floating Point Classify (Double-Precision)"
fmv.d.x    "Floating Point Move from Integer Register (Double-Precision)"

# RV64D    "RV64D Standard Extension for Double-Precision Floating-Point (in addition to RV32F)"

fcvt.l.d   "Floating Point Convert to Double Word (Double-Precision)"
fcvt.lu.d  "Floating Point Convert to Double Word Unsigned (Double-Precision)"
fcvt.d.l   "Floating Point Convert from Double Word (Double-Precision)"
fcvt.d.lu  "Floating Point Convert from Double Word Unsigned (Double-Precision)"

# RV32FD   "RV32F and RV32D Common Floating-Point Instructions"

frcsr      "Read Floating-point control and status register"
frrm       "Read Floating-point Rounding Mode"
frflags    "Read Floating-point Accrued Exception Flags"
fscsr      "Set Floating-point control and status register"
fsrm       "Set Floating-point Rounding Mode"
fsflags    "Set Floating-point Accrued Exception Flags"
fsrmi      "Set Floating-point Rounding Mode Immediate"
fsflagsi   "Set Floating-point Accrued Exception Flags Immediate"
